var documenterSearchIndex = {"docs":
[{"location":"ref-trixibase/#TrixiBase.jl-API","page":"TrixiBase","title":"TrixiBase.jl API","text":"","category":"section"},{"location":"ref-trixibase/#TrixiBase.disable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.disable_debug_timings","text":"disable_debug_timings()\n\nDisable all @trixi_timeit timings. The timings should be optimized away, allowing for truly zero-overhead. Enable timings again with enable_debug_timings.\n\nSee also enable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.enable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.enable_debug_timings","text":"enable_debug_timings()\n\nEnable all @trixi_timeit timings (default behavior).\n\nSee also disable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.timer-Tuple{}","page":"TrixiBase","title":"TrixiBase.timer","text":"timer()\n\nMain timer for global timing, e.g., to be used with @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include-Tuple{Function, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include","text":"trixi_include([mapexpr::Function=identity,] [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. Its basic purpose is to make it easier to modify some parameters while running simulations from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nBefore replacing assignments in elixir, the keyword argument maxiters is inserted into calls to solve with it's default value used in the SciML ecosystem for ODEs, see the \"Miscellaneous\" section of the documentation.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in elixir, the include function actually evaluates mapexpr(expr). If it is omitted, mapexpr defaults to identity.\n\nExamples\n\njulia> using TrixiBase, Trixi\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\n0.1\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include_changeprecision-Tuple{Any, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include_changeprecision","text":"trixi_include_changeprecision(T, [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the elixir elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments, similar to trixi_include.\n\nThe only difference to trixi_include is that the precision of floating-point numbers in the included elixir is changed to T. More precisely, the package ChangePrecision.jl is used to convert all Float64 literals, operations like / that produce Float64 results, and functions like ones that return Float64 arrays by default, to the desired type T. See the documentation of ChangePrecision.jl for more details.\n\nThe purpose of this function is to conveniently run a full simulation with Float32, which is orders of magnitude faster on most GPUs than Float64, by just including the elixir with trixi_include_changeprecision(Float32, elixir). Many constructors in the Trixi.jl framework are written in a way that changing all floating-point arguments to Float32 will change the element type to Float32 as well. In TrixiParticles.jl, including an elixir with this macro should be sufficient to run the full simulation with single precision.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.@trixi_timeit-Tuple{Any, Any, Any}","page":"TrixiBase","title":"TrixiBase.@trixi_timeit","text":"@trixi_timeit timer() \"some label\" expression\n\nBasically the same as a special case of @timeit_debug from TimerOutputs.jl, but without try ... finally ... end block. Thus, it's not exception-safe, but it also avoids some related performance problems. Since we do not use exception handling in Trixi.jl, that's not really an issue.\n\nAll @trixi_timeit timings can be disabled with disable_debug_timings. The timings should then be optimized away, allowing for truly zero-overhead.\n\nSee also disable_debug_timings, enable_debug_timings.\n\n\n\n\n\n","category":"macro"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT License","category":"page"},{"location":"license/","page":"License","title":"License","text":"Copyright (c) 2025-present Joshua Lampert <joshua.lampert@uni-hamburg.de> and contributors","category":"page"},{"location":"license/","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you have any suggestions or ideas for improvements or new features, we are pleased to accept and discuss issues or if you are willing to contribute, feel free to open a pull request, even if it is only fixing a typo or improving the docs.","category":"page"},{"location":"development/#Changing-SimpleDiscontinuousGalerkin.jl-and-running-it-locally","page":"Development","title":"Changing SimpleDiscontinuousGalerkin.jl and running it locally","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you plan to edit SimpleDiscontinuousGalerkin.jl, you first need to clone a local copy of the repository, which can be done by using git. It is recommended that you create a project, e.g. call it run, inside the repository, where you can add packages that you use during executing and testing SimpleDiscontinuousGalerkin.jl, but are not needed by SimpleDiscontinuousGalerkin.jl. This way you can keep the Project.toml of the main repository clean. To do so, you can execute the following lines in a terminal:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"git clone https://github.com/JoshuaLampert/SimpleDiscontinuousGalerkin.jl.git\ncd SimpleDiscontinuousGalerkin\nmkdir run\ncd run\njulia --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=\"..\"))' # Install local SimpleDiscontinuousGalerkin.jl clone\njulia --project=. -e 'using Pkg; Pkg.add([\"OrdinaryDiffEqLowStorageRK\", \"Plots\"])' # Install additional packages","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"If you use other packages for executing SimpleDiscontinuousGalerkin.jl, you can add them to the project in the run directory in an analogous way as above. To use the Julia project within run, be sure to start the Julia REPL by","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"if already inside the the run directory or julia --project=run if in the main directory of the repo.","category":"page"},{"location":"development/#Preview-of-the-documentation","page":"Development","title":"Preview of the documentation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you want to build the documentation locally, you can run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"once from the SimpleDiscontinuousGalerkin.jl main directory to tell Documenter.jl to build the documentation of your local clone. To build the documentation, run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs --color=yes docs/make.jl","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"The resulting .html files can then be found in docs/build/ and you can look at them by opening them in a browser. For pull requests from the main repository (i.e. not from a fork), the documentation is automatically built and can be previewed under https://JoshuaLampert.github.io/SimpleDiscontinuousGalerkin.jl/previews/PRXXX/ where XXX is the number of the pull request.","category":"page"},{"location":"ref/#SimpleDiscontinuousGalerkin.jl-API","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.jl API","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.SimpleDiscontinuousGalerkin","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SimpleDiscontinuousGalerkin","text":"SimpleDiscontinuousGalerkin\n\nSimpleDiscontinuousGalerkin.jl is a Julia package that implements some basic discontinuous Galerkin (DG) methods for the solution of hyperbolic partial differential equations (PDEs). The package is designed to be simple and easy to use and understand. It is intended for educational purposes and to provide a starting point for more complex DG methods. For a more comprehensive and advanced implementation of DG methods, we recommend using the package Trixi.jl. This package can be understood as a minimalistic version of Trixi.jl, which is designed to be easy to understand and modify. Many design concepts are inspired by Trixi.jl, but the implementation is much simpler and more straightforward.\n\nSimpleDiscontinuousGalerkin.jl builds on the foundations of the package SummationByPartsOperators.jl.\n\nSee also: SimpleDiscontinuousGalerkin.jl\n\n\n\n\n\n","category":"module"},{"location":"ref/#Equations","page":"SimpleDiscontinuousGalerkin","title":"Equations","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.AbstractEquations","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.AbstractEquations","text":"AbstractEquations{NDIMS, NVARS}\n\nAn abstract supertype of specific equations such as the linear advection equation. The type parameters encode the number of spatial dimensions (NDIMS) and the number of primary variables (NVARS) of the physics model.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.cons2cons-Tuple{Any, SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.cons2cons","text":"cons2cons(u, equations)\n\nReturn the conservative variables u. While this function is as trivial as identity, it is also as useful.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.eachvariable-Tuple{SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.eachvariable","text":"eachvariable(equations::AbstractEquations)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the variables in equations. In particular, not the variables themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.get_name-Tuple{SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.get_name","text":"get_name(equations::AbstractEquations)\n\nReturn the canonical, human-readable name for the given system of equations.\n\nExamples\n\njulia> SimpleDiscontinuousGalerkin.get_name(LinearAdvectionEquation1D(1.0))\n\"LinearAdvectionEquation1D\"\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.LinearAdvectionEquation1D","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.LinearAdvectionEquation1D","text":"LinearAdvectionEquation1D\n\nThe linear scalar advection equation\n\npartial_t u + a partial_1 u  = 0\n\nin one space dimension with constant velocity a.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_godunov-Tuple{Any, Any, LinearAdvectionEquation1D}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_godunov","text":"flux_godunov(u_ll, u_rr, equations::LinearAdvectionEquation1D)\n\nGodunov (upwind) flux for the 1D linear scalar advection equation. Essentially first order upwind, see e.g. https://math.stackexchange.com/a/4355076/805029 .\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.flux_central-Tuple{Any, Any, SimpleDiscontinuousGalerkin.AbstractEquations}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.flux_central","text":"flux_central(u_ll, u_rr, orientation_or_normal_direction, equations::AbstractEquations)\n\nThe classical central numerical flux f((u_ll) + f(u_rr)) / 2. When this flux is used as volume flux, the discretization is equivalent to the classical weak form DG method (except floating point errors).\n\n\n\n\n\n","category":"method"},{"location":"ref/#Mesh","page":"SimpleDiscontinuousGalerkin","title":"Mesh","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.Mesh","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Mesh","text":"Mesh\n\nStruct that holds the information for a simple homogeneous one-dimensional mesh.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.Mesh-Tuple{Any, Any, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Mesh","text":"Mesh(xmin, xmax, N_elements)\n\nCreate a simple homogeneous one-dimensional mesh from xmin to xmax with N_elements elements.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Boundary-conditions","page":"SimpleDiscontinuousGalerkin","title":"Boundary conditions","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.boundary_condition_do_nothing","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.boundary_condition_do_nothing","text":"boundary_condition_do_nothing = BoundaryConditionDoNothing()\n\nImposing no boundary condition just evaluates the flux at the inner state.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#SimpleDiscontinuousGalerkin.boundary_condition_periodic","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.boundary_condition_periodic","text":"boundary_condition_periodic = BoundaryConditionPeriodic()\n\nA singleton struct indicating periodic boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#SimpleDiscontinuousGalerkin.BoundaryConditionDirichlet","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.BoundaryConditionDirichlet","text":"BoundaryConditionDirichlet(boundary_value_function)\n\nCreate a Dirichlet boundary condition that uses the function boundary_value_function to specify the values at the boundary. This can be used to create a boundary condition that specifies exact boundary values by passing the exact solution of the equation. The passed boundary value function will be called with the same arguments as an initial condition function is called, i.e., as\n\nboundary_value_function(x, t, equations)\n\nwhere x specifies the coordinates, t is the current time, and equation is the corresponding system of equations.\n\nExamples\n\njulia> BoundaryConditionDirichlet(initial_condition_convergence_test)\n\n\n\n\n\n","category":"type"},{"location":"ref/#Solver","page":"SimpleDiscontinuousGalerkin","title":"Solver","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.DG","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.DG","text":"DG(; basis, surface_integral, volume_integral)\n\nCreate a discontinuous Galerkin method. If basis isa LegendreDerivativeOperator, this creates a DGSEM.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.eachnode-Tuple{SimpleDiscontinuousGalerkin.DG}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.eachnode","text":"eachnode(dg::DG)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the nodes in dg. In particular, not the nodes themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.DGSEM","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.DGSEM","text":"DGSEM(; RealT=Float64, polydeg::Integer,\n        surface_flux=flux_central,\n        surface_integral=SurfaceIntegralWeakForm(surface_flux),\n        volume_integral=VolumeIntegralWeakForm(),\n        mortar=MortarL2(basis))\n\nCreate a discontinuous Galerkin spectral element method (DGSEM) using a LegendreDerivativeOperator with polynomials of degree polydeg.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.FDSBP","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.FDSBP","text":"FDSBP(D; RealT=Float64,\n         surface_flux=flux_central,\n         surface_integral=SurfaceIntegralWeakForm(surface_flux),\n         volume_integral=VolumeIntegralWeakForm(),\n         mortar=MortarL2(basis))\n\nCreate a discontinuous Galerkin method using a summation-by-parts operator D from SummationByPartsOperators.jl. This is similar to the DGSEM, but uses a general derivative operator instead of a Legendre derivative operator.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.SurfaceIntegralStrongForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SurfaceIntegralStrongForm","text":"SurfaceIntegralStrongForm(surface_flux=flux_central, surface_flux_boundary=surface_flux)\n\nThe classical strong form surface integral type for FD/DG methods. It uses surface_flux for the interior fluxes and surface_flux_boundary for the boundary fluxes.\n\nSee also VolumeIntegralStrongForm.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.SurfaceIntegralWeakForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SurfaceIntegralWeakForm","text":"SurfaceIntegralWeakForm(surface_flux=flux_central, surface_flux_boundary=surface_flux)\n\nThe classical weak form surface integral type for DG methods as explained in standard textbooks. It uses surface_flux for the interior fluxes and surface_flux_boundary for the boundary fluxes.\n\nSee also VolumeIntegralWeakForm.\n\nReferences\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\nHesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications doi: 10.1007/978-0-387-72067-8\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencing","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencing","text":"VolumeIntegralFluxDifferencing(volume_flux=flux_central)\n\nVolume integral type for DG methods based on SBP operators and flux differencing using a symmetric two-point volume_flux. This volume_flux needs to satisfy the interface of numerical fluxes.\n\nTo be used together with SurfaceIntegralWeakForm.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencingStrongForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralFluxDifferencingStrongForm","text":"VolumeIntegralFluxDifferencingStrongForm(volume_flux=flux_central)\n\nVolume integral type for DG methods based on SBP operators and flux differencing using a symmetric two-point volume_flux. This volume_flux needs to satisfy the interface of numerical fluxes.\n\nThis is the strong formulation, which means it should be used together with SurfaceIntegralStrongForm.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralStrongForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralStrongForm","text":"VolumeIntegralStrongForm()\n\nThe classical strong form volume integral type for FD/DG methods.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.VolumeIntegralWeakForm","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.VolumeIntegralWeakForm","text":"VolumeIntegralWeakForm()\n\nThe classical weak form volume integral type for DG methods as explained in standard textbooks.\n\nReferences\n\nKopriva (2009) Implementing Spectral Methods for Partial Differential Equations: Algorithms for Scientists and Engineers doi: 10.1007/978-90-481-2261-5\nHesthaven, Warburton (2007) Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Applications doi: 10.1007/978-0-387-72067-8\n\n\n\n\n\n","category":"type"},{"location":"ref/#Semidiscretization","page":"SimpleDiscontinuousGalerkin","title":"Semidiscretization","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.Semidiscretization","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Semidiscretization","text":"Semidiscretization\n\nA struct containing everything needed to describe a spatial semidiscretization of an equation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#SimpleDiscontinuousGalerkin.Semidiscretization-NTuple{4, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.Semidiscretization","text":"Semidiscretization(mesh, equations, initial_condition, solver;\n                   boundary_conditions = boundary_condition_periodic)\n\nConstruct a semidiscretization of a PDE.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SimpleDiscontinuousGalerkin.semidiscretize-Tuple{Semidiscretization, Any}","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.semidiscretize","text":"semidiscretize(semi::Semidiscretization, tspan)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SummationByPartsOperators.grid-Tuple{Semidiscretization}","page":"SimpleDiscontinuousGalerkin","title":"SummationByPartsOperators.grid","text":"grid(semi)\n\nGet the grid of a semidiscretization.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Callbacks","page":"SimpleDiscontinuousGalerkin","title":"Callbacks","text":"","category":"section"},{"location":"ref/#SimpleDiscontinuousGalerkin.SummaryCallback","page":"SimpleDiscontinuousGalerkin","title":"SimpleDiscontinuousGalerkin.SummaryCallback","text":"SummaryCallback(io::IO = stdout)\n\nCreate and return a callback that resets the timer at the beginning of a simulation and prints the timer values at the end of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"#SimpleDiscontinuousGalerkin.jl","page":"Home","title":"SimpleDiscontinuousGalerkin.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs-dev) (Image: Build Status) (Image: codecov) (Image: Aqua QA) (Image: License: MIT)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleDiscontinuousGalerkin.jl is a Julia package that implements some basic discontinuous Galerkin (DG) methods for the solution of hyperbolic partial differential equations (PDEs). The package is designed to be simple and easy to use and understand. It is intended for educational purposes and to provide a starting point for more complex DG methods. For a more comprehensive and advanced implementation of DG methods, we recommend using the package Trixi.jl. This package can be understood as a minimalistic version of Trixi.jl, which is designed to be easy to understand and modify. Many design concepts are inspired by Trixi.jl, but the implementation is much simpler and more straightforward. SimpleDiscontinuousGalerkin.jl builds on the foundations of the package SummationByPartsOperators.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, then you first need to download Julia. Please follow the instructions for your operating system. SimpleDiscontinuousGalerkin.jl works with Julia v1.10 and newer. You can install SimpleDiscontinuousGalerkin.jl by executing the following commands from the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"https://github.com/JoshuaLampert/SimpleDiscontinuousGalerkin.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, first load the package SimpleDiscontinuousGalerkin.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SimpleDiscontinuousGalerkin","category":"page"},{"location":"","page":"Home","title":"Home","text":"SimpleDiscontinuousGalerkin.jl is built on top of the package SummationByPartsOperators.jl and exports all the functions and types of the package.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed and maintained by Joshua Lampert (University of Hamburg).","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimpleDiscontinuousGalerkin.jl is published under the MIT license (see License). We are pleased to accept contributions from everyone, preferably in the form of a PR.","category":"page"}]
}
